var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import secp256k1 from 'secp256k1';
import { fetchSenderInfo } from './query';
import { createTxContext } from './payload';
import { signDirect, signEIP712 } from './sign';
import { broadcastTx } from './broadcast';
import { wallet } from './params';
class NetworkTestClient {
    constructor() {
        this.signDirectAndBroadcast = (createTxPayload) => __awaiter(this, void 0, void 0, function* () {
            return this.signAndBroadcast(createTxPayload, signDirect);
        });
        this.signEIP712AndBroadcast = (createTxPayload) => __awaiter(this, void 0, void 0, function* () {
            return this.signAndBroadcast(createTxPayload, signEIP712);
        });
        this.signAndBroadcast = (createTxPayload, signPayload) => __awaiter(this, void 0, void 0, function* () {
            const context = yield this.createTxContext();
            const payload = createTxPayload(context);
            const signedTx = yield signPayload(payload);
            const response = yield broadcastTx(signedTx);
            console.log(response);
            if (this.nonce !== undefined) {
                this.nonce += 1;
            }
            return response;
        });
        this.createTxContext = () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { account_number, sequence, pub_key } = yield this.getSenderAccount();
            const pk = (_a = pub_key === null || pub_key === void 0 ? void 0 : pub_key.key) !== null && _a !== void 0 ? _a : this.getSignerPubKey();
            if (this.nonce === undefined) {
                this.nonce = parseInt(sequence, 10);
            }
            return createTxContext(account_number, pk, this.nonce.toString());
        });
        this.getSenderAccount = () => __awaiter(this, void 0, void 0, function* () {
            const senderInfo = yield fetchSenderInfo();
            if (!senderInfo) {
                throw new Error('Expected sender info from node');
            }
            return senderInfo.account.base_account;
        });
        this.getSignerPubKey = () => {
            const pkUncompressed = Buffer.from(wallet.publicKey.replace('0x', ''), 'hex');
            const pk = Buffer.from(secp256k1.publicKeyConvert(pkUncompressed, true));
            return pk.toString('base64');
        };
    }
}
export default NetworkTestClient;
//# sourceMappingURL=client.js.map