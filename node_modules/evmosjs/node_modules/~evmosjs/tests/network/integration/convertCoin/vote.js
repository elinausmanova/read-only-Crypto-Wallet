var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createTxMsgVote } from '@evmos/transactions';
import IntegrationClientBase from '../types';
import { fetchProposals } from '../../query';
class ConvertCoinVoteClient extends IntegrationClientBase {
    constructor() {
        super(...arguments);
        this.sendTx = () => __awaiter(this, void 0, void 0, function* () {
            return this.networkClient.signDirectAndBroadcast(this.createPayload);
        });
        this.createPayload = (context) => {
            const { proposalId } = this;
            if (!proposalId) {
                throw new Error('must set proposal id before generating');
            }
            const params = this.getParams(proposalId);
            return createTxMsgVote(context, params);
        };
        this.getParams = (proposalId) => {
            const option = 1;
            return {
                proposalId,
                option,
            };
        };
        this.setProposalId = (proposalId) => {
            this.proposalId = proposalId;
        };
        this.verifyStateChange = () => __awaiter(this, void 0, void 0, function* () {
            const response = yield fetchProposals();
            const { proposals } = response;
            const { proposalId } = this;
            if (!proposalId) {
                throw new Error('must set proposal id before verifying state');
            }
            expect(proposals.length).toBeGreaterThanOrEqual(proposalId);
            const proposal = proposals[proposalId - 1];
            this.verifyProposalPassed(proposal);
        });
        this.verifyProposalPassed = (proposal) => {
            expect(proposal.status).toBe('PROPOSAL_STATUS_PASSED');
        };
    }
}
export default ConvertCoinVoteClient;
//# sourceMappingURL=vote.js.map