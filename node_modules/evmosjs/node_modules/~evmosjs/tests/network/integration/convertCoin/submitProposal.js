var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createTxMsgSubmitProposal } from '@evmos/transactions';
import { createMsgRegisterCoin, Proto } from '@evmos/proto';
import IntegrationClientBase from '../types';
import { ibcDenom, denom } from '../../params';
import { fetchProposals } from '../../query';
class ConvertCoinSubmitProposalClient extends IntegrationClientBase {
    constructor() {
        super(...arguments);
        this.sendTx = () => __awaiter(this, void 0, void 0, function* () {
            this.previousProposals = yield fetchProposals();
            return this.networkClient.signDirectAndBroadcast(this.createPayload);
        });
        this.createPayload = (context) => {
            const params = this.getParams(context);
            return createTxMsgSubmitProposal(context, params);
        };
        this.getParams = (context) => {
            const token = 'token';
            const title = 'Test Token';
            const tokenDescription = 'Test token';
            const ibcUnit = new Proto.Cosmos.Bank.Bank.DenomUnit({
                denom: ibcDenom,
                exponent: 0,
                aliases: ['ibctoken'],
            });
            const baseUnit = new Proto.Cosmos.Bank.Bank.DenomUnit({
                denom: token,
                exponent: 6,
            });
            const metadata = new Proto.Cosmos.Bank.Bank.Metadata({
                description: tokenDescription,
                denomUnits: [ibcUnit, baseUnit],
                base: ibcDenom,
                display: token,
                name: title,
                symbol: token,
            });
            const content = createMsgRegisterCoin('Register Test - Convert Coin', 'Description', [metadata]);
            const deposit = '100000000000';
            const proposer = context.sender.accountAddress;
            return {
                content,
                denom,
                amount: deposit,
                proposer,
            };
        };
        this.getProposalId = () => {
            const previousProposals = this.getPreviousProposals();
            return previousProposals.proposals.length + 1;
        };
        this.verifyStateChange = () => __awaiter(this, void 0, void 0, function* () {
            const proposals = yield fetchProposals();
            const previousProposals = this.getPreviousProposals();
            expect(proposals.proposals).toHaveLength(previousProposals.proposals.length + 1);
        });
        this.getPreviousProposals = () => {
            const { previousProposals } = this;
            if (!previousProposals) {
                throw new Error('must fetch previous proposals before verifying state');
            }
            return previousProposals;
        };
    }
}
export default ConvertCoinSubmitProposalClient;
//# sourceMappingURL=submitProposal.js.map