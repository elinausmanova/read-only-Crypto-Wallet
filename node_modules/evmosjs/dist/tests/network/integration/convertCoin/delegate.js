var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createTxMsgDelegate } from '@evmos/transactions';
import { BigNumber } from '@ethersproject/bignumber';
import IntegrationClientBase from '../types';
import { denom } from '../../params';
import { fetchValidators } from '../../query';
class ConvertCoinDelegateClient extends IntegrationClientBase {
    constructor() {
        super(...arguments);
        this.stakeAmount = '500000000000000000000000000';
        this.sendTx = () => __awaiter(this, void 0, void 0, function* () {
            this.previousValidators = yield fetchValidators();
            return this.networkClient.signDirectAndBroadcast(this.createPayload);
        });
        this.createPayload = (context) => {
            const validatorAddress = this.getValidatorAddress();
            const params = this.getParams(validatorAddress);
            return createTxMsgDelegate(context, params);
        };
        this.getValidatorAddress = () => {
            const { previousValidators } = this;
            if (!previousValidators) {
                throw new Error('must fetch validators before getting validator address');
            }
            return previousValidators.validators[0].operator_address;
        };
        this.getParams = (validatorAddress) => {
            const amount = this.stakeAmount;
            return {
                validatorAddress,
                amount,
                denom,
            };
        };
        this.verifyStateChange = () => __awaiter(this, void 0, void 0, function* () {
            const response = yield fetchValidators();
            expect(this.stateIncludesDelegation(response)).toBe(true);
        });
        this.stateIncludesDelegation = (response) => {
            const delegation = BigNumber.from(response.validators[0].tokens);
            const target = BigNumber.from(this.stakeAmount);
            return delegation.gte(target);
        };
    }
}
export default ConvertCoinDelegateClient;
//# sourceMappingURL=delegate.js.map