var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createTxMsgConvertCoin } from '@evmos/transactions';
import { BigNumber } from '@ethersproject/bignumber';
import { JsonRpcProvider } from '@ethersproject/providers';
import { Contract } from '@ethersproject/contracts';
import IntegrationClientBase from '../types';
import { ibcDenom, senderAddress, senderHex, jsonRPCUrl } from '../../params';
import { fetchBalanceByDenom, fetchERC20ContractAddress } from '../../query';
class ConvertCoinConvertCoinClient extends IntegrationClientBase {
    constructor() {
        super(...arguments);
        this.transferAmount = '1000';
        this.sendTx = () => __awaiter(this, void 0, void 0, function* () {
            this.previousBalanceResponse = yield fetchBalanceByDenom(senderAddress, ibcDenom);
            return this.networkClient.signDirectAndBroadcast(this.createPayload);
        });
        this.createPayload = (context) => {
            const params = this.getParams();
            return createTxMsgConvertCoin(context, params);
        };
        this.getParams = () => {
            const amount = this.transferAmount;
            const denom = ibcDenom;
            const receiverHex = senderHex;
            const senderBech32 = senderAddress;
            return {
                denom,
                amount,
                receiverHex,
                senderBech32,
            };
        };
        this.verifyStateChange = () => __awaiter(this, void 0, void 0, function* () {
            yield this.verifyIBCBalanceStateChange();
            yield this.verifyERC20StateChange();
        });
        this.verifyIBCBalanceStateChange = () => __awaiter(this, void 0, void 0, function* () {
            const { previousBalanceResponse } = this;
            if (!previousBalanceResponse) {
                throw new Error('must fetch previous ibc balance before checking state change');
            }
            const balanceResponse = yield fetchBalanceByDenom(senderAddress, ibcDenom);
            this.verifyIBCBalanceDecreased(previousBalanceResponse.balance, balanceResponse.balance);
        });
        this.verifyIBCBalanceDecreased = (previous, current) => {
            const previousBalance = BigNumber.from(previous.amount);
            const currentBalance = BigNumber.from(current.amount);
            const diff = BigNumber.from(this.transferAmount);
            expect(currentBalance.toString()).toStrictEqual(previousBalance.sub(diff).toString());
        };
        this.verifyERC20StateChange = () => __awaiter(this, void 0, void 0, function* () {
            const contractAddress = yield this.fetchContractAddress();
            const balance = yield this.fetchContractBalance(contractAddress);
            const expBalance = BigNumber.from(this.transferAmount);
            expect(balance.toString()).toBe(expBalance.toString());
        });
        this.fetchContractAddress = () => __awaiter(this, void 0, void 0, function* () {
            const response = yield fetchERC20ContractAddress();
            const tokenPairs = response.token_pairs;
            const latestPair = tokenPairs[tokenPairs.length - 1];
            return latestPair.erc20_address;
        });
        this.fetchContractBalance = (address) => __awaiter(this, void 0, void 0, function* () {
            const provider = new JsonRpcProvider(jsonRPCUrl);
            const abi = ['function balanceOf(address owner) view returns (uint256)'];
            const contract = new Contract(address, abi, provider);
            const balance = yield contract.balanceOf(senderHex);
            return balance;
        });
    }
}
export default ConvertCoinConvertCoinClient;
//# sourceMappingURL=convertCoin.js.map